#include <assert.h>
#include "mechanics.h"
#include "state.h"
#include "world.h"


void *scale_world(void *world_, double scale) {
  world_t *world = world_;
  world_t *result = make_world();
  for (int i=0; i<world->states.size; i++) {
    state_t *state = get_pointer(world->states)[i];
    append_pointer(&result->states, scale_state(state, scale));
  };
  return result;
}

void *add_worlds(void *a_, void *b_) {
  world_t *a = a_;
  world_t *b = b_;
  world_t *result = make_world();
  assert(a->states.size == b->states.size);
  for (int i=0; i<a->states.size; i++) {
    state_t *s1 = get_pointer(a->states)[i];
    state_t *s2 = get_pointer(b->states)[i];
    append_pointer(&result->states, add_states(s1, s2));
  };
  return result;
}

state_t *state_change(state_t *s, body_t b, forces_t f, vector_t p, vector_t t, double dt) {
  vector_t position_change = vector_scale(s->speed, dt);
  vector_t speed_change_ = speed_change(f, b, p, dt);
  quaternion_t orientation_change = quaternion_product(vector_to_quaternion(vector_scale(s->rotation, 0.5 * dt)), s->orientation);
  vector_t rotation_change_ = rotation_change(s, f, b, t, dt);
  return state(position_change, speed_change_, orientation_change, rotation_change_);
}

void *world_change(double time, double dt, void *world_, void *data_) {
  world_t *world = world_;
  world_t *result = make_world();
  world_info_t *data = data_;
  assert(data->bodies.size == world->states.size);
  assert(data->forces.size == world->states.size);
  assert(data->rigid_bodies.size == world->states.size);
  // Rotate and translate the rigid bodies.
  list_t rigid_bodies = make_list();
  for (int i=0; i<data->rigid_bodies.size; i++) {
    rigid_body_t * rigid_body = get_pointer(data->rigid_bodies)[i];
    state_t *state = get_pointer(world->states)[i];
    append_pointer(&rigid_bodies, transform_body(rigid_body, state->orientation, state->position));
  };
  // Determine all contacts between rigid bodies.
  list_t contacts_ = make_list();
  for (int i=0; i<rigid_bodies.size; i++) {
    for (int j=i+1; j<rigid_bodies.size; j++) {
      rigid_body_t *body = get_pointer(rigid_bodies)[i];
      rigid_body_t *other = get_pointer(rigid_bodies)[j];
      list_t contacts_of_bodies = contacts(i, j, body, other);
      for (int c=0; c<contacts_of_bodies.size; c++)
        append_contact(&contacts_, get_contact(contacts_of_bodies)[c]);
    };
  };
  // Initialise linear and rotational impulses to zero.
  vector_t p[world->states.size]; memset(p, 0, sizeof(p));
  vector_t t[world->states.size]; memset(t, 0, sizeof(t));
  vector_t p1[contacts_.size]; memset(p1, 0, sizeof(p1));
  vector_t p2[contacts_.size]; memset(p2, 0, sizeof(p2));
  vector_t t1[contacts_.size]; memset(t1, 0, sizeof(t1));
  vector_t t2[contacts_.size]; memset(t2, 0, sizeof(t2));
  // Perform sequential impulses for several iterations.
  for (int c=0; c<data->iterations; c++) {
    // Apply impulses generated by joints.
    for (int k=0; k<data->joints.size; k++) {
      joint_t joint = get_joint(data->joints)[k];
      state_t *s1 = get_pointer(world->states)[joint.i];
      state_t *s2 = get_pointer(world->states)[joint.j];
      body_t body1 = get_body(data->bodies)[joint.i];
      body_t body2 = get_body(data->bodies)[joint.j];
      forces_t forces1 = get_forces(data->forces)[joint.i];
      forces_t forces2 = get_forces(data->forces)[joint.j];
      state_t *prediction1 = predict(s1, body1, forces1, p[joint.i], t[joint.i], dt);
      state_t *prediction2 = predict(s2, body2, forces2, p[joint.j], t[joint.j], dt);
      vector_t p1; vector_t p2; vector_t t1; vector_t t2;
      joint_impulse(body1, body2, joint, prediction1, prediction2, &p1, &p2, &t1, &t2);
      p[joint.i] = vector_add(p[joint.i], p1);
      p[joint.j] = vector_add(p[joint.j], p2);
      t[joint.i] = vector_add(t[joint.i], t1);
      t[joint.j] = vector_add(t[joint.j], t2);
    };
    // Apply impulses generated by contacts.
    for (int k=0; k<contacts_.size; k++) {
      contact_t c = get_contact(contacts_)[k];
      int i = c.i;
      int j = c.j;
      state_t *s1 = get_pointer(world->states)[i];
      state_t *s2 = get_pointer(world->states)[j];
      body_t body1 = get_body(data->bodies)[i];
      body_t body2 = get_body(data->bodies)[j];
      forces_t forces1 = get_forces(data->forces)[i];
      forces_t forces2 = get_forces(data->forces)[j];
      p[i] = vector_subtract(p[i], p1[k]);
      p[j] = vector_subtract(p[j], p2[k]);
      t[i] = vector_subtract(t[i], t1[k]);
      t[j] = vector_subtract(t[j], t2[k]);
      state_t *prediction1 = predict(s1, body1, forces1, p[i], t[i], dt);
      state_t *prediction2 = predict(s2, body2, forces2, p[j], t[j], dt);
      contact_impulse(body1, body2, prediction1, prediction2, c, &p1[k], &p2[k], &t1[k], &t2[k]);
      p[i] = vector_add(p[i], p1[k]);
      p[j] = vector_add(p[j], p2[k]);
      t[i] = vector_add(t[i], t1[k]);
      t[j] = vector_add(t[j], t2[k]);
    };
  };
  // Create resulting list of state changes.
  for (int i=0; i<world->states.size; i++) {
    state_t *s = get_pointer(world->states)[i];
    body_t b = get_body(data->bodies)[i];
    forces_t f = get_forces(data->forces)[i];
    state_t *change = state_change(s, b, f, p[i], t[i], dt);
    append_pointer(&result->states, change);
  };
  return result;
}
